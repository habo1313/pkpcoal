import numpy as np
import os
from scipy import stats
import pylab as plt
import shutil
from scipy.integrate import odeint
import scipy.interpolate
import platform

from Models import BalancedComposition
from PreProc import PreProcResult
from CoalThermoPhysics import MolWeights, EnthOfForm

OS = platform.system()

class CPDResult(PreProcResult):

    # Following data has been previously returned
    # CPD_Result1: 0=Time 2=Temp 4=ftar 5=fgas 6=fsolid   7=ftot
    # CPD_Result4: 2=fh2O 3=fco2 4=fch4 5=fco  6=fother
    # NOTE GO: last line of CPD_Result1 is a duplicate
    solver = "CPD"

    def __init__(self, coal, runNr,
        folder=False, dct=False):
        self.coal = coal
        self.tempProfile = coal.d['OperatingConditions'][runNr]
        self.timesteps = 1 # unfortunately cpd write only 4 digits after comma
                           # so for small time steps we have to skip identical
                           # values
        if folder != False:
            files = ["CPD_Result{}.dat".format(i) for i in range(1,5)]
            self.data   = {fn:CPDResult.readResults(folder + fn) for fn in files}
            self.header = {fn:CPDResult.readHeader(folder + fn) for fn in files}
        elif dct:
            self.data = dct['data']
            self.header = dct['header']

    def __getitem__(self, item):
        def find_file(item):
            for fn, names in self.header.iteritems():
                if item in names:
                    return fn, names.index(item)
            else:
                print "cannot find", item, fn, names #TODO GO replace by error
        if not 'time' in item:
            fn, column = find_file(item)
            return self.data[fn][column][::self.timesteps]
        elif item == 'time':
            # make sure that we return time only
            # in SI units
            fn, column = find_file('time(ms)')
            return self.data[fn][column][::self.timesteps]/1000.0
        elif item == 'time(ms)':
            # make sure that we return time only
            # in SI units
            fn, column = find_file('time(ms)')
            return self.data[fn][column][::self.timesteps]

    @property
    def _tsv(self):
        # out = {name: list(data) for name, data in self.iterspecies()}
        fields = ['time', 'fch4', 'fco', 'temp', "fh20", "fco2", "fother", "fgas", "ftot"]
        header = " ".join(fields)
        s = ""
        for i,_ in enumerate(self.__getitem__('time(ms)')):
            for spec in fields:
                s += str(list(self.__getitem__(spec))[i]) + "\t"
            s += "\n"
        return header + "\n" + s

    @property
    def speciesNames(self):
        # TODO GO why on earth is it h2zero?
        return ["fh20", "fco2", "fch4", "fco", "fother", "ftot", "fgas", "ftar"]


    def rate(self, species):
        """ returns the release rate of the species """
        import numpy as np
        species = self.__getitem__(species)
        time = self.__getitem__("time")
        dt = np.diff(time)
        dt = np.append(time[0], dt)
        return np.gradient(species, dt)

    def iterspecies(self):
        for name in self.speciesNames:
            yield name, self.__getitem__(name)

    @classmethod
    def readResults(cls, fn):
        """ read results generated by cpd executable """
        # TODO GO is it safe to say that cpd always writes 4 files?
        import numpy
        import re
        from StringIO import StringIO
        with open(fn) as f:
            # since cpd uses different numbers of whitespaces
            # in results files we sanitize them first
            fn_str = re.sub('(?<=[0-9])[ ]+',',',f.read())
            fn_str = re.sub('[ ]+','',fn_str)
            # TODO GO why is the data transposed
            if "CPD_Result1.dat" in fn:
                return (numpy.genfromtxt(
                    StringIO(fn_str),
                    delimiter=',',
                    skip_header=1,
                    dtype=float)[0:-1]).transpose()
            else:
                return numpy.genfromtxt(
                    StringIO(fn_str),
                    delimiter=',',
                    skip_header=1,
                    dtype=float).transpose()

    @classmethod
    def readHeader(cls, fn):
        """ return column names from a cpd results file header """
        with open(fn) as f:
            header = f.readline().split()[1:] # Remove first entry
        return header

    @classmethod
    def writeResults(cls, folder):
        """ read results generated by cpd executable """
        pass

    def interpolate(self, field):
        """ Outputs the interpolation object (e.g.Species(time)) """
        # ODE-Solver needs a continous T(t), managed with an interpolation,
        # the T(t) interpolation is extended to a value 10*t with const.
        # T for ODE (requires more time t the end):
        OrderOfTimeInterpolation=1
        t = self.__getitem__('time')
        t = np.append(np.array(0), t)
        data = self.__getitem__(field)
        data = np.append(np.array(data[0]), data)
        return scipy.interpolate.interp1d(
            t, # list(t) + [10*t[-1]]),
            data, # list(T) + [10*T[-1]]),
            bounds_error=False,
            fill_value=data[-1], # NOTE if out of bounds fill with last value
        )

    @property
    def qFactor(self):
        """ Qfactor is defined as q = m_vol/m_volProx,
            hence we can use f_tot/m_volProx """
        #TODO Base Qfactor on DAF
        vm = self.coal.pa_daf["Volatile Matter"]
        return self.ftot*100.0/vm

    @property
    def pa_raw(self):
        """ the composition of the raw molecule """
        ftot = self.ftot*100.0
        return {'Fixed Carbon': 100.0 - ftot,
                'Volatile Matter': ftot}

    @property
    def ftot(self):
        """ the total yield as kg/kg_coal_daf
            #TODO is ftot based on daf or as recieved?
         """
        return self.__getitem__("ftot")[-1]

class SetAndLaunchBase(object):
    runNr=0
    printIntervall=1
    writeIntervall=1

class CPD(SetAndLaunchBase):
    """ This class is able to write the CPD input file and launch the CPD program.
        Before writing the CPD input file (method 'writeInstructFile') set all parameter
        using the corresponding methods (SetCoalParameter, SetOperateCond, SetNumericalParam,
        CalcCoalParam). After writing the instruct file, the .Run method can be used."""

    cpd_constants = {
           'ab'     : 2.602e15,
           'eb'     : 55400,
           'ebsig'  : 1800,
           'ac'     : 0.9,
           'ec'     : 0,
           'ag'     : 3.0e15,
           'eg'     : 69000,
           'egsig'  : 8100,
           'Acr'    : 3.0e15,
           'Ecr'    : 65000,
           'arad'   : 18.4,
           'erad'   : 6000,
           'fstable': 0.03,
           'an'     : 5.5e7,
           'en'     : 90000,
           'ensig'  : 0,
           'nmax'   : 20,
        }

    execDir = os.path.expanduser('~') + "/.pkp/CPD/" # os.getcwd()+"/CPD/"
    resDirDefault = execDir + "Results/"

    def __init__(self,
            coal,
            pressure,
            deltaT,
            runNr = 'run0',
            resDir = False,
        ):
        self.runNr = runNr
        # NOTE we scale the tempProfile to pass time in ms as CPD expects
        tempProfile = coal.d['OperatingConditions'][runNr]
        tempProfile = [(time*1000.0, temp) for time, temp in tempProfile]
        self.tempProfile = self.timeTempProfile(tempProfile) # TODO give it a better name
        self.pressure    = pressure
        # We scale ua and daf data for cpd since input is not in percents
        self.coal        = coal
        self.ultim_ana   = coal.ua.scale(0.01)
        self.daf         = coal.pa_daf.scale(0.01)
        self.coal_param  = CPD.CalcCoalParam(self.ultim_ana, self.daf)
        self.output_dict = {
            'num_time' : len(tempProfile),
            'pressure' : self.pressure,
            'deltaT'   : deltaT,
            'strTempProfile': self.tempProfile,
            'printIntervall': self.printIntervall,
            'writeIntervall': self.writeIntervall,
        }
        # for generating the output string
        # all the dicts are merge into one
        self.output_dict.update(self.cpd_constants)
        self.output_dict.update(self.ultim_ana.elems)
        self.output_dict.update(self.coal_param)
        self.output_dict.update(self.daf.elems)
        self.output_dict.update(self.__dict__)
        self.output_dict.update({'t_final': tempProfile[-1][0]})
        self.writen_inputs = False
        resDir = (resDir if resDir else self.resDirDefault)
        self.resDir = "{}{}/".format(resDir, runNr)

    @classmethod
    def calcC0(cls, massFracCarbon, massFracOx):
        c0 = 0.0
        #TODO GO are these really mutually exclusive?
        #       what happens if c > 0.859 and ox > 0.123
        #TODO GO double check if correct
        if massFracCarbon > 0.859:
            c0 = min(0.36, 11.83*massFracCarbon - 10.16)
        elif massFracOx > 0.125:
            c0 = min(0.15, 1.4*massFracOx - 0.175)
        return c0


    @classmethod
    def CalcCoalParam(cls, ultim_ana, daf):
        """ Calculates the CPD coal parameter mdel, mw, p0, sig
            and returns as dictionary

            equations from: http://www.et.byu.edu/~tom/cpd/correlation.html
        """
        c=np.array([
               [ 0.0    ,  0.0    ,  0.0     ,  0.0],
               [ 421.957,  1301.41,  0.489809, -52.1054],
               [-864.692,  1638.79, -0.981566,  163.872],
               [ 463.894, -1874.93,  1.33046 , -107.548],
               [-847.272, -45477.3,  15.5483 , -123.688],
               [ 11817.3,  517109., -243.873 ,  931.937],
               [ 115.366, -1007.20,  0.705248, -16.5673],
               [-434.024,  760.827,  2.19163 ,  40.9556],
               [ 55.6772,  136.022, -1.10498 ,  0.926097],
               [-65.4575, -313.561,  1.00939 , -0.826717],
        ])

        Y = [(c[1,i]
                 + c[2,i]*ultim_ana['Carbon']
                 + c[3,i]*ultim_ana['Carbon']**2
                 + c[4,i]*ultim_ana['Hydrogen']
                 + c[5,i]*ultim_ana['Hydrogen']**2
                 + c[6,i]*ultim_ana['Oxygen']
                 + c[7,i]*ultim_ana['Oxygen']**2
                 + c[8,i]*daf['Volatile Matter']
                 + c[9,i]*daf['Volatile Matter']**2)
                for i in range(4)]


        return {'c0'   : CPD.calcC0(ultim_ana['Carbon'], ultim_ana['Oxygen']),
                'mdel' : Y[0],
                'mw'   : Y[1],
                'p0'   : Y[2],
                'sig'  : Y[3]}



    def timeTempProfile(self, tempProfile):
        """ Returns a string from yaml read temp profile, basically reversing the yaml read function
            Probably there is a more direct way

            NOTE: CPD excepts input time in (ms), but seconds are prefered as input
                  hence we convert the times here
        """
        #return '\n'.join(["{} {}".format(time, temp) for time, temp in tempProfile.iteritems()])
        return '\n'.join([' '.join(map(str,_)) for _ in tempProfile])

    def writeInstructFile(self):
        """Writes the File 'CPD_input.dat' into the directory Dirpath."""
        if not os.path.exists(self.resDir):
            os.makedirs(self.resDir)
        ini=open(self.execDir+'CPD_input.dat','w')#Keywords:1-15,args:16-70
        #TODO GO is fcar,fhyd ... from daf or ua ?
        #TODO GO where does timax and nmax come frome
        ini_str = """{p0:<20} ! p0
{c0:<20} ! c0
{sig:<20} ! sig+1
{mw:<20} ! mw
{mdel:<20} ! mdel (7 will be subtracted internally to the CPD model
{Carbon:<20} ! fcar (daf mass fraction of carbon in unreacted coal)
{Hydrogen:<20} ! fhyd (daf mass fraction of hydrogen in unreacted coal)
{Nitrogen:<20} ! fnit (daf mass fraction of nitrogen in unreacted coal)
{Oxygen:<20} ! foxy (daf mass fraction of oxygen in unreacted coal)
{ab:<20} ! ab
{eb:<20} ! eb
{ebsig:<20} ! ebsig
{ac:<20} ! ac=rho
{ec:<20} ! ec
{ag:<20} ! ag
{eg:<20} ! eg
{egsig:<20} ! egsig
{Acr:<20} ! Acr (pre-exponential factor for crosslinking rate)
{Ecr:<20} ! Ecr (activation energy for crosslinking rate)
{arad:<20} ! arad (pre-exponential factor for N attack by free radical)
{erad:<20} ! erad (activation energy for N attack by free radical, cal.)
{fstable:<20} ! fstable (initial frac. of MW decay with no radical N attack)
{an:<20} ! an (high T slow N release pre-exponential factor)
{en:<20} ! en (high T slow N release activation energy, calories)
{ensig:<20} ! ensig (deviation bound for distribution of en)
{pressure:<20} ! pressure (atm)
{num_time:<20} ! number of time points
{strTempProfile}
{deltaT} {printIntervall} {deltaT} ! dt (s), print increment, max dt (s))
{t_final:<20}  ! timax (maximum residence time [s] for calculations))
{nmax:<20} ! nmax (maximum number of mers for tar molecular wt))
""".format(**self.output_dict)
        ini.write(ini_str)
        ini.close()
        self.writen_inputs = True


    def writeInDat(self):
        inps_str = self.execDir + "CPD_input.dat\n"
        inps_str +=  "\n".join([self.resDir + "CPD_Result{}.dat".format(f) for f in range(1,5)])
        ini=open(self.execDir+'IN.dat','w')
        ini.write(inps_str)
        ini.close()


    def Run(self, inp_file="IN.dat", verbose=False):
        """Launches the CPD executable and inputs Input_File.

           TODO: Store Results in subfolder
        """
        import pkp.bins
        if not self.writen_inputs:
            self.writeInstructFile()
            self.writeInDat()

        cpdExec =  os.path.dirname(pkp.bins.__file__)
        if OS == 'Linux':
            exe = '{}/cpdnlg'.format(cpdExec)
        elif OS == 'Darwin':
            exe = '{}/cpdnlg.x'.format(cpdExec)
        elif OS == 'Windows':
            exe = '{}cpdnlg.exe'.format(cpdExec)
        else:
            print "The name of the operating system couldn't be found."
            return
        OScommand='{} < {}{} > {}CPD_{}_output.log'.format(
                        exe, self.execDir, inp_file, self.resDir, self.runNr)
        if verbose:
            print OScommand
        os.system(OScommand)
        return CPDResult(runNr=self.runNr, folder=self.resDir, coal=self.coal)
