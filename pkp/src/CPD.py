import numpy as np
import os
from scipy import stats
import pylab as plt
import shutil
from scipy.integrate import odeint
import scipy.interpolate
import platform

from Models import BalancedComposition
OS = platform.system()

################################
R=1.0 #8.3144621 # Gas constant only =8.3... if E should not include R

MolWeights = { #g/mol
    'Oxygen':16.,
    'Carbon':12.,
    'Hydrogen':1.,
    'Nitrogen':14.,
    'CO': 28.,
    'CO2': 44.,
    'H2O': 18.,
}

EnthOfForm = { # in [kJ/kmol]
    'CO':  -110541.0, # Turns p. 622
    'CO2': -393546.0, # Turns p. 623
    'H2O': -241845.0, # Turns p. 632
}

EnthOfFormKG = {name: value/MolWeights[name]
        for name, value in EnthOfForm.iteritems()}

CoresProd = {
    'Carbon':'CO',
    'Hydrogen':'H2O',
}

################################

class CPDResult(object):

    # Following data has been previously returned
    # CPD_Result1: 0=Time 2=Temp 4=ftar 5=fgas 6=fsolid   7=ftot
    # CPD_Result4: 2=fh2O 3=fco2 4=fch4 5=fco  6=fother
    # NOTE GO: last line of CPD_Result1 is a duplicate
    solver = "CPD"

    def __init__(self, folder=False, dct=False):
        if folder != False:
            files = ["CPD_Result{}.dat".format(i) for i in range(1,5)]
            self.data   = {fn:CPDResult.readResults(folder + fn) for fn in files}
            self.header = {fn:CPDResult.readHeader(folder + fn) for fn in files}
        elif dct:
            self.data = dct['data']
            self.header = dct['header']

    def __getitem__(self, item):
        def find_file(item):
            for fn, names in self.header.iteritems():
                if item in names:
                    return fn, names.index(item)
            else:
                print "cannot find", item, fn, names #TODO GO replace by error
        if not 'time' in item:
            fn, column = find_file(item)
            return self.data[fn][column]
        elif item == 'time':
            # make sure that we return time only
            # in SI units
            fn, column = find_file('time(ms)')
            return self.data[fn][column]/1000.0
        elif item == 'time(ms)':
            # make sure that we return time only
            # in SI units
            fn, column = find_file('time(ms)')
            return self.data[fn][column]

    @property
    def _tsv(self):
        # out = {name: list(data) for name, data in self.iterspecies()}
        fields = ['time', 'fch4', 'fco', 'temp', "fh20", "fco2", "fother", "fgas", "ftot"]
        header = " ".join(fields)
        s = ""
        for i,_ in enumerate(self.__getitem__('time(ms)')):
            for spec in fields:
                s += str(list(self.__getitem__(spec))[i]) + "\t"
            s += "\n"
        return header + "\n" + s

    @property
    def speciesNames(self):
        # TODO GO why on earth is it h2zero?
        return ["fh20", "fco2", "fch4", "fco", "fother", "ftot", "fgas", "ftar"]


    def iterspecies(self):
        for name in self.speciesNames:
            yield name, self.__getitem__(name)

    @classmethod
    def readResults(cls, fn):
        """ read results generated by cpd executable """
        # TODO GO is it safe to say that cpd always writes 4 files?
        import numpy
        import re
        from StringIO import StringIO
        with open(fn) as f:
            # since cpd uses different numbers of whitespaces
            # in results files we sanitize them first
            fn_str = re.sub('(?<=[0-9])[ ]+',',',f.read())
            fn_str = re.sub('[ ]+','',fn_str)
            # TODO GO why is the data transposed
            if "CPD_Result1.dat" in fn:
                return (numpy.genfromtxt(
                    StringIO(fn_str),
                    delimiter=',',
                    skip_header=1,
                    dtype=float)[0:-1]).transpose()
            else:
                return numpy.genfromtxt(
                    StringIO(fn_str),
                    delimiter=',',
                    skip_header=1,
                    dtype=float).transpose()

    @classmethod
    def readHeader(cls, fn):
        """ return column names from a cpd results file header """
        with open(fn) as f:
            header = f.readline().split()[1:] # Remove first entry
        return header

    @classmethod
    def writeResults(cls, folder):
        """ read results generated by cpd executable """
        pass

    def interpolate(self, field):
        """ Outputs the interpolation object (e.g.Species(time)) """
        # ODE-Solver needs a continous T(t), managed with an interpolation,
        # the T(t) interpolation is extended to a value 10*t with const.
        # T for ODE (requires more time t the end):
        OrderOfTimeInterpolation=1
        t = self.__getitem__('time(ms)')
        data = self.__getitem__(field)
        return scipy.interpolate.interp1d(
            t, # list(t) + [10*t[-1]]),
            data, # list(T) + [10*T[-1]]),
            # kind=OrderOfTimeInterpolation,
            # axis=-1,
            bounds_error=False,
            fill_value=data[-1], # NOTE if out of bounds fill with last value
        )

    def Qfactor(self, proximate_analysis):
        """ Qfactor is defined as q = m_vol/m_volProx,
            hence we can use f_tot/m_volProx """
        #TODO Base Qfactor on DAF
        ftot =  self.__getitem__("ftot")[-1]
        vm = (BalancedComposition(proximate_analysis)
              .remove_elems_rebalance(['Moisture','Ash'])
              ["Volatile Matter"])
        return ftot*100.0/vm

    def VolatileCompositionMass(self, proximate_analysis, ultimate_analysis):
        """ m_species/m_tot
            where:
                m_tot = m_h + m_o + m_vc_cur

            The difficulty is to know the carbon content of the
            volatile yield.
                m_c_ua = m_fc_prox + m_vc_prox
                m_c_ua = m_fc_cur + m_vc_cur

                m_vc_cur = m_c_ua - m_fc_prox/q_factor
        """
        #TODO Base Qfactor on DAF
        ua = ultimate_analysis
        pa = BalancedComposition(proximate_analysis).remove_elems_rebalance(['Moisture','Ash'])
        carbon = (ua['Carbon']-pa['Fixed Carbon']/self.Qfactor(pa))
        oxygen = ua['Oxygen']
        hydrogen = ua['Hydrogen']
        nitrogen = ua['Nitrogen']
        tot = carbon + oxygen + hydrogen + nitrogen
        assert tot < 100.0
        return {'Carbon': carbon/tot,
                'Hydrogen': hydrogen/tot,
                'Oxygen': oxygen/tot,
                'Nitrogen': nitrogen/tot
                }

    def VolatileCompositionMol(self,
            proximate_analysis,
            ultimate_analysis,
            molar_mass_vm):
        comp_mass = self.VolatileCompositionMass(
                proximate_analysis,
                ultimate_analysis
            )
        return {elem: comp_mass[elem]/mw*molar_mass_vm
                for elem, mw in MolWeights.iteritems()
                if elem in comp_mass.keys()}

    def ProductCompositionMol(self,
            proximate_analysis,
            ultimate_analysis,
            molar_mass_vm):
        comp_mass = self.VolatileCompositionMol(
                proximate_analysis,
                ultimate_analysis,
                molar_mass_vm
            )
        CO = comp_mass['Carbon']*molar_mass_vm/MolWeights['CO']
        H2O = comp_mass['Hydrogen']*molar_mass_vm/MolWeights['H2O']*0.5
        return {'CO':CO, 'H2O':H2O}

    def EnthalpyOfFormation(self,
            proximate_analysis,
            ultimate_analysis,
            molar_mass_vm,
            LHV # kJ/kg
            ):
        """ Computes the enthalpy of formation of the volatile matter

            h_react = LHV + sum(n_i h_prod_i) with n beeing stoich factor

            Parameters:
                molar_mass_mv in [kg/kmol]
                LHV in [kJ/kg]
        """
        # NOTE
        # first we get the molar composition of the volatile matter,
        # with that we can compute the product compostion per mol vm
        vol_comp = self.ProductCompositionMol(
            proximate_analysis,
            ultimate_analysis,
            molar_mass_vm)
        H_products = 0.0
        # for every element in the volatile composition we get the
        # corresponding product and its enthapy of formation kJ/kmol
        for name, mol in vol_comp.iteritems():
            # Hydrogen gives beta/2*H2O
            h_prod = EnthOfForm.get(name, 0.0)
            H_products += mol*h_prod
        h_0f = (LHV*molar_mass_vm+H_products) # [kJ/kmol]
        return h_0f, h_0f/4184.0



class SetAndLaunchBase(object):
    runNr=0
    printIntervall=1
    writeIntervall=1

class CPD(SetAndLaunchBase):
    """ This class is able to write the CPD input file and launch the CPD program.
        Before writing the CPD input file (method 'writeInstructFile') set all parameter
        using the corresponding methods (SetCoalParameter, SetOperateCond, SetNumericalParam,
        CalcCoalParam). After writing the instruct file, the .Run method can be used."""

    cpd_constants = {
           'ab'     : 2.602e15,
           'eb'     : 55400,
           'ebsig'  : 1800,
           'ac'     : 0.9,
           'ec'     : 0,
           'ag'     : 3.0e15,
           'eg'     : 69000,
           'egsig'  : 8100,
           'Acr'    : 3.0e15,
           'Ecr'    : 65000,
           'arad'   : 18.4,
           'erad'   : 6000,
           'fstable': 0.03,
           'an'     : 5.5e7,
           'en'     : 90000,
           'ensig'  : 0,
           'nmax'   : 20,
        }

    execDir = os.path.expanduser('~') + "/.pkp/CPD/" # os.getcwd()+"/CPD/"
    resDirDefault = execDir + "Results/"

    def __init__(self,
            ultimateAnalysis,
            proximateAnalysisDaf,
            tempProfile,
            pressure,
            deltaT,
            runNr = 0,
            resDir = False,
        ):
        self.runNr = runNr
        self.tempProfile = self.timeTempProfile(tempProfile) # TODO give it a better name
        self.pressure    = pressure
        # We scale ua and daf data for cpd since input is not in percents
        self.ultim_ana   = ultimateAnalysis.scale(0.01)
        self.daf         = proximateAnalysisDaf.scale(0.01)
        self.coal_param  = CPD.CalcCoalParam(self.ultim_ana, self.daf)
        self.output_dict = {
            'num_time' : len(tempProfile),
            'pressure' : self.pressure,
            'deltaT'   : deltaT,
            'strTempProfile': self.tempProfile,
            'printIntervall': self.printIntervall,
            'writeIntervall': self.writeIntervall,
        }
        # for generating the output string
        # all the dicts are merge into one
        self.output_dict.update(self.cpd_constants)
        self.output_dict.update(self.ultim_ana.elems)
        self.output_dict.update(self.coal_param)
        self.output_dict.update(self.daf.elems)
        self.output_dict.update(self.__dict__)
        self.writen_inputs = False
        resDir = (resDir if resDir else self.resDirDefault)
        self.resDir = "{}Run{}/".format(resDir, runNr)

    @classmethod
    def calcC0(cls, massFracCarbon, massFracOx):
        c0 = 0.0
        #TODO GO are these really mutually exclusive?
        #       what happens if c > 0.859 and ox > 0.123
        #TODO GO double check if correct
        if massFracCarbon > 0.859:
            c0 = min(0.36, 11.83*massFracCarbon - 10.16)
        elif massFracOx > 0.125:
            c0 = min(0.15, 1.4*massFracOx - 0.175)
        return c0


    @classmethod
    def CalcCoalParam(cls, ultim_ana, daf):
        """ Calculates the CPD coal parameter mdel, mw, p0, sig
            and returns as dictionary

            equations from: http://www.et.byu.edu/~tom/cpd/correlation.html
        """
        c=np.array([
               [ 0.0    ,  0.0    ,  0.0     ,  0.0],
               [ 421.957,  1301.41,  0.489809, -52.1054],
               [-864.692,  1638.79, -0.981566,  163.872],
               [ 463.894, -1874.93,  1.33046 , -107.548],
               [-847.272, -45477.3,  15.5483 , -123.688],
               [ 11817.3,  517109., -243.873 ,  931.937],
               [ 115.366, -1007.20,  0.705248, -16.5673],
               [-434.024,  760.827,  2.19163 ,  40.9556],
               [ 55.6772,  136.022, -1.10498 ,  0.926097],
               [-65.4575, -313.561,  1.00939 , -0.826717],
        ])

        Y = [(c[1,i]
                 + c[2,i]*ultim_ana['Carbon']
                 + c[3,i]*ultim_ana['Carbon']**2
                 + c[4,i]*ultim_ana['Hydrogen']
                 + c[5,i]*ultim_ana['Hydrogen']**2
                 + c[6,i]*ultim_ana['Oxygen']
                 + c[7,i]*ultim_ana['Oxygen']**2
                 + c[8,i]*daf['Volatile Matter']
                 + c[9,i]*daf['Volatile Matter']**2)
                for i in range(4)]


        return {'c0'   : CPD.calcC0(ultim_ana['Carbon'], ultim_ana['Oxygen']),
                'mdel' : Y[0],
                'mw'   : Y[1],
                'p0'   : Y[2],
                'sig'  : Y[3]}



    def timeTempProfile(self,tempProfile):
        """ Returns a string from yaml read temp profile, basically reversing the yaml read function
            Probably there is a more direct way
        """
        #return '\n'.join(["{} {}".format(time, temp) for time, temp in tempProfile.iteritems()])
        return '\n'.join([' '.join(map(str,_)) for _ in tempProfile])

    def writeInstructFile(self):
        """Writes the File 'CPD_input.dat' into the directory Dirpath."""
        if not os.path.exists(self.resDir):
            os.makedirs(self.resDir)
        ini=open(self.execDir+'CPD_input.dat','w')#Keywords:1-15,args:16-70
        #TODO GO is fcar,fhyd ... from daf or ua ?
        #TODO GO where does timax and nmax come frome
        ini_str = """{p0:<20} ! p0
{c0:<20} ! c0
{sig:<20} ! sig+1
{mw:<20} ! mw
{mdel:<20} ! mdel (7 will be subtracted internally to the CPD model
{Carbon:<20} ! fcar (daf mass fraction of carbon in unreacted coal)
{Hydrogen:<20} ! fhyd (daf mass fraction of hydrogen in unreacted coal)
{Nitrogen:<20} ! fnit (daf mass fraction of nitrogen in unreacted coal)
{Oxygen:<20} ! foxy (daf mass fraction of oxygen in unreacted coal)
{ab:<20} ! ab
{eb:<20} ! eb
{ebsig:<20} ! ebsig
{ac:<20} ! ac=rho
{ec:<20} ! ec
{ag:<20} ! ag
{eg:<20} ! eg
{egsig:<20} ! egsig
{Acr:<20} ! Acr (pre-exponential factor for crosslinking rate)
{Ecr:<20} ! Ecr (activation energy for crosslinking rate)
{arad:<20} ! arad (pre-exponential factor for N attack by free radical)
{erad:<20} ! erad (activation energy for N attack by free radical, cal.)
{fstable:<20} ! fstable (initial frac. of MW decay with no radical N attack)
{an:<20} ! an (high T slow N release pre-exponential factor)
{en:<20} ! en (high T slow N release activation energy, calories)
{ensig:<20} ! ensig (deviation bound for distribution of en)
{pressure:<20} ! pressure (atm)
{num_time:<20} ! number of time points
{strTempProfile}
{deltaT} {printIntervall} {deltaT} ! dt (s), print increment, max dt (s))
0.03                    ! timax (maximum residence time [s] for calculations))
{nmax:<20} ! nmax (maximum number of mers for tar molecular wt))
""".format(**self.output_dict)
        ini.write(ini_str)
        ini.close()
        self.writen_inputs = True


    def writeInDat(self):
        inps_str = self.execDir + "CPD_input.dat\n"
        inps_str +=  "\n".join([self.resDir + "CPD_Result{}.dat".format(f) for f in range(1,5)])
        ini=open(self.execDir+'IN.dat','w')
        ini.write(inps_str)
        ini.close()


    def Run(self, inp_file="IN.dat"):
        """Launches the CPD executable and inputs Input_File.

           TODO: Store Results in subfolder
        """
        import pkp.bins
        if not self.writen_inputs:
            self.writeInstructFile()
            self.writeInDat()

        cpdExec =  os.path.dirname(pkp.bins.__file__)
        if OS == 'Linux':
            exe = '{}/cpdnlg'.format(cpdExec)
        elif OS == 'Darwin':
            exe = '{}/cpdnlg.x'.format(cpdExec)
        elif OS == 'Windows':
            exe = '{}cpdnlg.exe'.format(cpdExec)
        else:
            print "The name of the operating system couldn't be found."
            return
        OScommand='{} < {}{} > {}CPD_{}_output.log'.format(
                        exe, self.execDir, inp_file, self.resDir, self.runNr)
        print OScommand
        os.system(OScommand)
        return CPDResult(folder=self.resDir)

